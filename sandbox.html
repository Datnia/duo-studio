<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="apple-touch-icon"
      type="image/png"
      href="https://static.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png"
    />
    <meta name="apple-mobile-web-app-title" content="CodePen" />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="https://static.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico"
    />
    <link
      rel="mask-icon"
      type=""
      href="https://static.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg"
      color="#111"
    />
    <title>CodePen - BabylonJS - Fisheye on scroll</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css"
    />
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      #wrapper {
        position: relative;
        z-index: 1;
      }

      #app {
        height: 100%;
        left: 0;
        position: fixed;
        top: 0;
        touch-action: none;
        width: 100%;
      }

      .section {
        height: 100vh;
        position: relative;
      }

      .grid {
        display: grid;
        grid-gap: 2vw;
        grid-template-columns: repeat(2, 1fr);
        padding: 3vw 2vw;
      }

      .grid--narrow {
        padding-left: 15vw;
        padding-right: 15vw;
      }

      .grid--tall {
        padding-bottom: 15vh;
        padding-top: 15vh;
      }

      .cell {
        display: -webkit-box;
        display: flex;
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        flex-direction: column;
        -webkit-box-pack: center;
        justify-content: center;
      }

      img {
        max-width: 100%;
      }

      p {
        line-height: 1.5;
      }

      .text-right {
        text-align: right;
      }

      .flex-center {
        -webkit-box-align: center;
        align-items: center;
        display: -webkit-box;
        display: flex;
        -webkit-box-pack: center;
        justify-content: center;
      }

      .flex-column {
        -webkit-box-orient: vertical;
        -webkit-box-direction: normal;
        flex-direction: column;
      }

      .heading {
        font-weight: 700;
        font-size: 280%;
        margin: 0;
      }

      .app-title {
        font-size: 4vw;
        padding: 10vw 0;
        min-height: 40vh;
        font-weight: 600;
      }

      .app-title__text {
        margin: 0 10vw 0.7em;
        text-align: center;
      }

      .js-webgl-image:hover {
        cursor: pointer;
      }

      .js-webgl-element-hidden {
        opacity: 0;
      }

      .load-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        color: white;
        font-size: 260%;
        z-index: 10;
        background-color: #121314;
        -webkit-transition: opacity 0.5s;
        transition: opacity 0.5s;
      }

      .load-screen.hidden {
        opacity: 0;
        touch-action: none;
        pointer-events: none;
      }
    </style>
    <script>
      window.console = window.console || function (t) {};
    </script>
    <script>
      if (document.location.search.match(/type=embed/gi)) {
        window.parent.postMessage("resize", "*");
      }
    </script>
  </head>
  <body translate="no">
    <div class="load-screen flex flex-center hidden">
      Loading images üñºÔ∏è ...
    </div>
    <div id="wrapper">
      <div class="grid grid--narrow grid--tall">
        <div class="cell">
          <img
            src="https://picsum.photos/id/1025/480/640"
            class="js-webgl-image js-webgl-element-hidden"
            alt=""
          />
        </div>
        <div class="cell">
          <p class="heading js-webgl-text js-webgl-element-hidden">
            Hello Codepen üëã
          </p>
          <p class="js-webgl-text js-webgl-element-hidden">
            Scroll the page and hover the images to see some WebGL magic üòé
          </p>
        </div>
      </div>
      <div class="app-title flex-center">
        <p class="app-title__text js-webgl-text js-webgl-element-hidden">
          All the images and texts are rendered in a single WebGL canvas below
          the page content
        </p>
      </div>
      <div class="grid grid--narrow">
        <div class="cell">
          <img
            src="https://picsum.photos/id/1015/580/640"
            class="js-webgl-image js-webgl-element-hidden"
            alt=""
          />
        </div>
        <div class="cell">
          <p class="heading js-webgl-text js-webgl-element-hidden">
            Miniaturization
          </p>
          <p class="js-webgl-text js-webgl-element-hidden">
            The urge to miniaturize electronics did not exist before the space
            program. I mean our grandparents had radios that was furniture in
            the living room. Nobody at the time was saying, 'Gee, I want to
            carry that in my pocket.' Which is a non-thought.
          </p>
        </div>
      </div>
      <div class="grid grid--narrow">
        <div class="cell">
          <p class="heading text-right js-webgl-text js-webgl-element-hidden">
            About exploration
          </p>
          <p class="text-right js-webgl-text js-webgl-element-hidden">
            The history of exploration has never been driven by exploration. But
            Columbus himself was a discoverer. So was Magellan. But the people
            who wrote checks were not. They had other motivations.
          </p>
        </div>
        <div class="cell">
          <img
            src="https://picsum.photos/id/1014/580/640"
            class="js-webgl-image js-webgl-element-hidden"
            alt=""
          />
        </div>
      </div>
      <div class="app-title flex-center flex-column">
        <p class="app-title__text js-webgl-text js-webgl-element-hidden">
          Feel free to fork üç¥, use, and enhance it!
        </p>
        <p class="app-title__text js-webgl-text js-webgl-element-hidden">
          But don't forget to leave a ‚ù§Ô∏è
        </p>
      </div>
      <div class="section flex-center">
        <img
          src="https://picsum.photos/id/1011/1000/667"
          class="js-webgl-image js-webgl-element-hidden"
          alt=""
        />
      </div>
    </div>
    <canvas
      id="app"
      touch-action="none"
      style="touch-action: none;"
      width="1903"
      height="514"
    ></canvas>
    <script src="https://static.codepen.io/assets/common/stopExecutionOnTimeout-157cd5b220a5c80d4ff8e0e70ac069bffd87a61252088146915e8726e5d9f147.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/4.0.3/babylon.js"></script>
    <script src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smoothscroll/1.4.9/SmoothScroll.min.js"></script>
    <script src="https://unpkg.com/tornis@0.2.1/dist/tornis.js?module"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs-gui@4.0.3/babylon.gui.min.js"></script>
    <script id="rendered-js">
      /**
       * HOW THIS WORKS:
       * Every image/text on the page has a specific CSS class:
       * `.js-webgl-image`
       * `.js-webgl-text`
       *
       * The `App` class goes through all the elements with those classes and calculates their bounding rects, updating each element's coordinates based on the scroll of the page + the bounding rects of the element.
       *
       * The script then hides every element by adding the `.js-webgl-element-hidden` CSS class to them.
       *
       * NOTE: The key part is the Camera type; to be able to have a 1:1 ratio from the real elements to the ones rendered in WebGL the camera has to be set to ORTHOGRAPHIC. Thanks to that, each value (width, height, etc...) set in WebGL corresponds to the pixel value.
       *
       * CREDITS:
       * - Fisheye shader: https://www.shadertoy.com/view/lttXD4
       * - Hover effect on the images: https://tympanus.net/codrops/2018/04/10/webgl-distortion-hover-effects/
       */

      class App {
        constructor({ images = [], texts = [] } = {}) {
          this.canvas = null;
          this.engine = null;
          this.scene = null;
          this.camera = null;

          this.images = images;
          this.activeImageIndex = 0;
          this.planesImg = new Array(this.images.length);
          this.planesImgBounds = new Array(this.images.length);

          this.texts = texts;
          this.planesTexts = new Array(this.texts.length);
          this.planesTextsBounds = new Array(this.texts.length);

          this.fisheyePP = null;
          this.fisheyeDistortion = { value: 0 };

          this.debug = false;

          this.animateInDispFactorCallback = (e) => this.animateInDispFactor(e);
          this.animateOutDispFactorCallback = () => this.animateOutDispFactor();
        }

        init() {
          this.setup();
          this.setElementsBounds();
          this.createElements();
          this.setElementsStyle();
          this.addListeners();
          this.setFisheye();

          console.log(this);
        }

        setup() {
          this.canvas = document.querySelector("#app");
          this.engine = new BABYLON.Engine(this.canvas, true, null, true);
          this.scene = new BABYLON.Scene(this.engine);
          this.scene.clearColor = BABYLON.Color3.White();

          // Lights
          const hemisphericLight = new BABYLON.HemisphericLight(
            "HemisphericLight",
            new BABYLON.Vector3(1, 1, 0),
            this.scene
          );

          // Camera
          this.camera = new BABYLON.ArcRotateCamera(
            "Camera",
            -Math.PI / 2,
            Math.PI / 2,
            10,
            BABYLON.Vector3.Zero(),
            this.scene
          );
          this.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;

          this.engine.runRenderLoop(() => this.scene.render());
        }

        createElements() {
          /*
           * Images
           */
          BABYLON.Effect.ShadersStore["imagesVertexShader"] = `
       precision highp float;
  
       // Attributes
       attribute vec3 position;
       attribute vec3 normal;
       attribute vec2 uv;
  
       // Uniforms
       uniform mat4 worldViewProjection;
  
       // Varying
       varying vec2 vUV;
  
       void main(void) {
           vec3 pos = position;
           gl_Position = worldViewProjection * vec4(pos, 1.0);
  
           vUV = uv;
       }
      `;
          BABYLON.Effect.ShadersStore["imagesFragmentShader"] = `
       precision highp float;
  
       uniform sampler2D u_mainTexture;
       uniform sampler2D u_secondaryTexture;
       uniform sampler2D u_displacementTexture;
  
       uniform float dispFactor;
       uniform float effectFactor;
  
       varying vec2 vUV;
  
       void main() {
         vec2 uv = vUV;
  
         vec4 disp = texture2D(u_displacementTexture, uv);
  
         vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r * effectFactor), uv.y);
         vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r * effectFactor), uv.y);
  
         vec4 _texture = texture2D(u_mainTexture, distortedPosition);
         vec4 _texture2 = texture2D(u_secondaryTexture, distortedPosition2);
  
         vec4 finalTexture = mix(_texture, _texture2, dispFactor);
  
         gl_FragColor = finalTexture;
       }
      `;

          const displacementImage = new BABYLON.Texture(
            "https://webgl-fisheye.netlify.com/displacement.jpg",
            this.scene,
            true
          );

          const baseMaterial = new BABYLON.ShaderMaterial(
            "DisplacementMaterial",
            this.scene,
            {
              vertex: "images",
              fragment: "images",
              attributes: ["position", "normal", "uv"],
              uniforms: ["worldViewProjection"],
            }
          );

          const baseMesh = new BABYLON.PlaneBuilder.CreatePlane(
            `BaseMesh`,
            {},
            this.scene
          );
          const numImages = this.images.length;

          for (let i = 0; i < numImages; i++) {
            if (window.CP.shouldStopExecution(0)) break;
            this.images[i].classList.add("js-webgl-element-hidden");
            this.planesImg[i] = baseMesh.clone(
              `Image${i.toString().padStart(3, "0")}`
            );
            this.planesImg[i].material = baseMaterial.clone(
              `Image0${i}Material`
            );
            this.planesImg[i].doNotSyncBoundingInfo = true;

            const mainTexture = new BABYLON.Texture(
              this.images[i].src.replace(window.location.href, ""),
              this.scene,
              true
            );
            const secondaryTexture = new BABYLON.Texture(
              this.images[i].src.replace(window.location.href, ""),
              this.scene,
              true
            );
            this.planesImg[i].material.setTexture("u_mainTexture", mainTexture);
            this.planesImg[i].material.setTexture(
              "u_secondaryTexture",
              secondaryTexture
            );
            this.planesImg[i].material.setTexture(
              "u_displacementTexture",
              displacementImage
            );
            this.planesImg[i].material.setFloat("dispFactor", 0);
            this.planesImg[i].material.setFloat("effectFactor", 0.5);
          }

          /*
           * Texts
           */ window.CP.exitedLoop(0);
          const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(
            "myUI"
          );
          const numTexts = this.texts.length;

          for (let i = 0; i < numTexts; i++) {
            if (window.CP.shouldStopExecution(1)) break;
            this.texts[i].classList.add("js-webgl-element-hidden");
            this.planesTexts[i] = new BABYLON.GUI.TextBlock(
              `${this.texts[i].textContent.substring(0, 10)} ...`,
              this.texts[i].textContent
            );
            this.setTextStyle({ plane: this.planesTexts[i], index: i });

            gui.addControl(this.planesTexts[i]);
          }
          window.CP.exitedLoop(1);
        }

        setElementsBounds() {
          // Images
          let num = this.images.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(2)) break;
            const bounds = this.images[i].getBoundingClientRect();

            this.planesImgBounds[i] = {
              x: bounds.x,
              y: bounds.y + (window.scrollY || window.pageYOffset),
              width: bounds.width,
              height: bounds.height,
            };
          }

          // Texts
          window.CP.exitedLoop(2);
          num = this.texts.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(3)) break;
            const bounds = this.texts[i].getBoundingClientRect();

            this.planesTextsBounds[i] = {
              x: bounds.x,
              y: bounds.y + (window.scrollY || window.pageYOffset),
              width: bounds.width,
              height: bounds.height,
            };
          }
          window.CP.exitedLoop(3);
        }

        setElementsStyle() {
          // Images
          let num = this.images.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(4)) break;
            this.planesImg[i].scaling.x = this.images[i].clientWidth;
            this.planesImg[i].scaling.y = this.images[i].clientHeight;
          }

          // Texts
          window.CP.exitedLoop(4);
          num = this.texts.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(5)) break;
            this.setTextStyle({ plane: this.planesTexts[i], index: i });
          }
          window.CP.exitedLoop(5);
        }

        setElementsPosition() {
          // Images
          let num = this.images.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(6)) break;
            this.planesImg[i].position.y =
              -this.planesImgBounds[i].height / 2 +
              this.canvas.clientHeight / 2 -
              this.planesImgBounds[i].y +
              (window.scrollY || window.pageYOffset);
            this.planesImg[i].position.x =
              this.planesImgBounds[i].width / 2 -
              this.canvas.clientWidth / 2 +
              this.planesImgBounds[i].x;
          }

          // Texts
          window.CP.exitedLoop(6);
          num = this.texts.length;
          for (let i = 0; i < num; i++) {
            if (window.CP.shouldStopExecution(7)) break;
            this.planesTexts[i].top =
              this.planesTextsBounds[i].height / 2 -
              this.canvas.clientHeight / 2 +
              this.planesTextsBounds[i].y -
              (window.scrollY || window.pageYOffset);
            this.planesTexts[i].left =
              this.planesTextsBounds[i].width / 2 -
              this.canvas.clientWidth / 2 +
              this.planesTextsBounds[i].x;
          }
          window.CP.exitedLoop(7);
        }

        setTextStyle({ plane, index }) {
          const style = getComputedStyle(this.texts[index]);

          plane.fontSize = style.fontSize;
          plane.fontFamily = style.fontFamily;
          plane.fontWeight = style.fontWeight;
          plane.resizeToFit = true;
          plane.textWrapping = true;
          plane.widthInPixels = this.texts[index].clientWidth;
          plane.heightInPixels = this.texts[index].clientHeight;

          // Text alignment and positioning
          switch (style.textAlign) {
            case "left":
            case "start":
              plane.textHorizontalAlignment =
                BABYLON.GUI.TextBlock.HORIZONTAL_ALIGNMENT_LEFT;
              plane.leftInPixels = this.texts[index].clientWidth / 2;
              break;
            case "right":
              plane.textHorizontalAlignment =
                BABYLON.GUI.TextBlock.HORIZONTAL_ALIGNMENT_RIGHT;
              plane.rightInPixels = -this.texts[index].clientWidth / 2;
              break;
            case "center":
              plane.textHorizontalAlignment =
                BABYLON.GUI.TextBlock._HORIZONTAL_ALIGNMENT_CENTER;
              break;
          }
        }

        animateDispFactor({ target, to }) {
          const prop = { value: target.material._floats.dispFactor };

          TweenMax.fromTo(
            prop,
            0.6,
            {
              value: target.material._floats.dispFactor,
            },

            {
              value: to,
              onUpdate: () => {
                target.material.setFloat("dispFactor", prop.value);
              },
            }
          );
        }

        animateInDispFactor(e) {
          this.activeImageIndex = this.images.indexOf(e.target);
          this.animateDispFactor({
            target: this.planesImg[this.activeImageIndex],
            to: 1,
          });
        }

        animateOutDispFactor() {
          this.animateDispFactor({
            target: this.planesImg[this.activeImageIndex],
            to: 0,
          });
        }

        animateFisheye({ value }) {
          TweenMax.to(this.fisheyeDistortion, 0.5, { value: value * 0.007 });
        }

        addListeners() {
          const numImages = this.images.length;
          for (let i = 0; i < numImages; i++) {
            if (window.CP.shouldStopExecution(8)) break;
            this.images[i].addEventListener(
              "pointerenter",
              this.animateInDispFactorCallback,
              { passive: true }
            );
            this.images[i].addEventListener(
              "pointerleave",
              this.animateOutDispFactorCallback,
              { passive: true }
            );
          }
          window.CP.exitedLoop(8);
        }

        removeListeners() {
          const numImages = this.images.length;
          for (let i = 0; i < numImages; i++) {
            if (window.CP.shouldStopExecution(9)) break;
            this.images[i].removeEventListener(
              "pointerenter",
              this.animateInDispFactorCallback,
              { passive: true }
            );
            this.images[i].removeEventListener(
              "pointerleave",
              this.animateOutDispFactorCallback,
              { passive: true }
            );
          }
          window.CP.exitedLoop(9);
        }

        setFisheye() {
          BABYLON.Effect.ShadersStore["fisheyeFragmentShader"] = `
       precision highp float;
  
       varying vec2 vUV;
  
       uniform sampler2D textureSampler;
       uniform vec2 u_resolution;
       uniform float u_distortion;
  
       // Forum post: http://www.html5gamedevs.com/topic/29295-fish-eye-and-reverse-fish-eye/?do=findComment&comment=168839
       // Playground: https://www.babylonjs-playground.com/#TRNYD#20
       void main() {
         vec2 uv = (gl_FragCoord.xy / u_resolution.xy) - vec2(0.5);
         float uva = atan(uv.x, uv.y);
         float uvd = sqrt(dot(uv, uv));
         float k = sin(u_distortion);
         uvd *= 1.0 + k*uvd*uvd;
  
         gl_FragColor = texture(textureSampler, vec2(0.5) + vec2(sin(uva), cos(uva))*uvd);
  
         // vec3 color = texture2D(textureSampler, vUV).xyz;
         // gl_FragColor = vec4(color, 1.0);
       }
      `;

          this.fisheyePP = new BABYLON.PostProcess(
            "fisheye",
            "fisheye",
            ["u_resolution", "u_distortion"],
            null,
            1,
            this.camera,
            0,
            this.engine
          );
          this.fisheyePP.onApply = (effect) => {
            effect.setFloat2(
              "u_resolution",
              this.fisheyePP.width,
              this.fisheyePP.height
            );
          };

          this.fisheyePP.onBeforeRenderObservable.add((effect) =>
            effect.setFloat("u_distortion", this.fisheyeDistortion.value)
          );
        }

        destroy() {
          this.removeListeners();
          this.engine.dispose();
        }
      }

      const app = new App({
        images: [...document.querySelectorAll(".js-webgl-image")],
        texts: [...document.querySelectorAll(".js-webgl-text")],
      });

      imagesLoaded("#wrapper", () => {
        document.querySelector(".load-screen").classList.add("hidden");

        app.init();

        const updateValues = ({ size, scroll }) => {
          if (size.changed) {
            app.engine.resize();
            app.setElementsBounds();
            app.setElementsStyle();
            app.setElementsPosition();
          }

          if (scroll.changed) {
            app.animateFisheye({ value: scroll.velocity.y });
            app.setElementsPosition();
          }
        };

        tornis.watchViewport(updateValues);
      });
      //# sourceURL=pen.js
    </script>
  </body>
</html>
